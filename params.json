{"name":"Sider","tagline":"SIDER : REDIS bindings for C#/.NET 4.0 -- Features clean API design that maps closely to actual Redis commands.","body":"SIDER : REDIS bindings for C#\r\n====\r\n\r\nFor the latest changes, please see the `CHANGES.markdown` file.\r\n\r\nInspired by migueldeicaza's first stab at the problem (I used some of his\r\nalgorithm) and ServiceStack.Redis (to take it a lot further).\r\n\r\n**If you have questions/feedbacks, please feel free to shoot it to\r\n[sider-lemonade@googlegroups.com](mailto:sider-lemonade@googlegroups.com),\r\nopen a [GitHub issue](https://github.com/chakrit/sider/issues/new) or\r\nping me on Twitter [@chakrit](http://twitter.com/chakrit)**\r\n\r\n**NOTE:** If you are going to run benchmarks against Sider codebase\r\nmake sure you have these [assertions](https://github.com/chakrit/sider/blob/master/src/Sider/SAssert.cs)\r\nturned off by running your test projects in RELEASE mode. Otherwise\r\nyou might get strange benchmarking results.\r\n\r\n# INSTALLATION\r\n\r\nThe quickest route to getting started with Redis using Sider is via\r\n[NuGet](http://nuget.org). Create a new console application and then open the\r\nPackage Manager Console (View -> Other Windows -> Package Manager Console) and\r\ntype in:\r\n\r\n    install-package sider\r\n\r\nThen in your `Program.cs` file, test it out with:\r\n\r\n    var client = new RedisClient();\r\n    client.Set(\"HELLOOO\", \"WORLD!!!!\");\r\n    Console.WriteLine(client.Get(\"HELLOOO\"));\r\n\r\n    Console.ReadKey();\r\n\r\nIf Redis 2.4 is running on the default host/port and everything is working\r\nproperly, you should see the string `\"WORLD!!!!\"` printed to your console.\r\n\r\n# ABOUT\r\n\r\nThis is a REDIS 2.2 bindings for C# 4.0 that try to **stick to the metal**\r\nas much as possible which results in:\r\n\r\n* Simple API that maps closely to the Redis commands reference.\r\n* Easy to use, no gigantic class hierarchies to setup. No confusing naming\r\n  convention that obfuscates the real command being sent to Redis.\r\n* Redis publish/subscribe via `IObservable`.\r\n* As fast as my limited networking skills and Redis itself will allow.\r\n  (Which is already lightning-fast thanks to Redis!)\r\n* Supports reading from and writing data to user-supplied streams for GET/SET\r\n  and other similar commands to allow Redis to be used to store really\r\n  really large blobs (e.g. user-uploaded files) without huge buffers.\r\n* Delegate-based pipelining support.\r\n\r\nAs of **April 26th, 2011**, all commands as\r\nper Redis 2.2 are now implemented with all options. Enjoy! :)\r\n\r\n# HOWTO\r\n\r\nHere's how to use the lib:\r\n\r\n    // connects to redis\r\n    var client = new RedisClient(); // default host:port\r\n    client = new RedisClient(\"localhost\", 6379); // custom host/port\r\n\r\n    // redis commands are methods of the RedisClient class\r\n    client.Set(\"HELLO\", \"World\");\r\n    var result = client.Get(\"HELLO\");\r\n    // result == \"World\";\r\n\r\n    client.Dispose() // disconnect\r\n\r\nFor ASP.NET/Web and/or multi-threaded concurrent access scenarios, it is\r\nrecommended that you use an IoC container to help you with client activations\r\nor you can use the `ThreadwisePool` like this:\r\n\r\n    // manages clients activations/disposal\r\n    var pool = new ThreadwisePool();\r\n\r\n    var client = pool.GetClient();\r\n    var result = client.Get(\"HELLO\") == \"WORLD\";\r\n\r\nInternally, a .NET 40 `ThreadLocal<T>` is used. Both the client and the clients pool can be plugged into an IoC by using the respective\r\n`IRedisClient` and `IClientsPool` interface respectively.\r\n\r\n# PIPELINE\r\n\r\nTo perform multiple pipelined calls, wrap your commands in a `.Pipeline` call:\r\n\r\n    // issue ~ 2k commands in one go\r\n    var result = client.Pipeline(c =>\r\n    {\r\n      for (var i = 0; i < 1000; i++)\r\n        c.Set(\"HELLO\" + i.ToString(), \"WORLD\" + i.ToString());\r\n\r\n      for (var i = 999; i >= 0; i--)\r\n        c.Get(\"HELLO\" + i.ToString()\r\n    });\r\n\r\n    // parse results\r\n    var resultArr = result.ToArray();\r\n    for (var i = 0; i < 1000; i++)          // SET results\r\n      Debug.Assert((bool)resultArr[i]); \r\n\r\n    for (var i = 999; i >= 0; i--) {        // GET results\r\n      Debug.Assert(resultArr[i] is string);\r\n      Debug.Assert(\"WORLD\" + i.ToString() == (string)resultArr[i]);\r\n    }\r\n\r\nResults are returned as an `IEnumerable<object>` with as many elements as\r\nthe number of calls you've made with each object having the same type as the\r\ncorresponding pipelined call.\r\n\r\nSince its an `IEnumerable<object>`, it also works with LINQ. See the\r\n`LinqPipelineSample.cs` file in the `src/Sider.Samples` folder for a \r\nsample implementation.\r\n\r\n**Strongly-typed extension**\r\n\r\nIf you only need a fixed number of calls which you can determine at compile-time\r\nthen you can use the extension method version of `.Pipeline` to help you with\r\ntype-casting.\r\n\r\nExample, for a fixed number of calls:\r\n\r\n    // fixed number of calls < 8\r\n    // each delegate must call exactly 1 redis command (i.e. IRedisClient method)\r\n    var result = client.Pipeline(\r\n      c => c.Get(\"KEY1\"),\r\n      c => c.MGet(\"KEY2\", \"KEY3\", \"KEY4\", \"KEY5\", \"KEY6\", \"KEY7\", \"KEY8\", \"KEY9\"),\r\n      c => c.Keys(\"MY_VERY_VERY_VERY_VERY_LONG_*_KEY_PTTRNS\"));\r\n    \r\n    string getResult = result.Item1;\r\n    string[] mGetResults = result.Item2;\r\n    string[] keysResults = result.Item3;\r\n\r\nThe returned value of these extension methods is a strongly-typed `Tuple<>`.\r\n\r\n**NOTE**\r\n\r\nNote that pipeline results are not lazy as is usually the case with\r\n`IEnumerable` implementations -- All commands will be executed immediately as\r\nsoon as you finish the `.Pipeline` call.\r\n\r\n# CUSTOM TYPE / SERIALIZERS\r\n\r\nTo use `RedisClient` with your own custom type to get automatic serialization,\r\njust add a type parameter like so:\r\n\r\n    var client = new RedisClient<MyClass>();\r\n    client.Set(\"instance\", new MyClass());\r\n\r\n    var mc = client.Get(\"instance\");\r\n    // mc typed as MyClass\r\n\r\nTo provide your own serialization mechanism, create a class that implements\r\n`Sider.Serialization.ISerializer<YourClassTypeHere>` and supply it to\r\nSider like so:\r\n\r\n    public class MyClass { }\r\n    public class MySerializer : ISerializer<MyClass> { /* -snip- */ }\r\n\r\n    var settings = RedisSettings.Build()\r\n      .OverrideSerializer(new MySerializer());\r\n\r\n    var client = new RedisClient<MyClass>(settings);\r\n    \r\n    // instance serialized and deserialized using your custom serializer\r\n    client.Set(\"instance\", new MyClass());\r\n    var value = client.Get(\"instance\")\r\n\r\nSee the `ComplexSetupSample.cs` file in the `src/Sider.Samples` folder for\r\na sample implementation.\r\n\r\n# BINARY DATA / STREAMING\r\n\r\nRight now raw binary data / streaming is supported for commands with a single\r\nvalue input/output such as `Get\\HGet\\GetRange` etc. The command which provides\r\nraw/streamed mode will have a `Raw` and `To/From` prefix/suffix such as\r\n`GetRaw\\SetRaw` for raw mode and `GetTo\\SetFrom` for streamed mode.\r\n\r\nI assumed that you will want to work with raw/streamed data only when you really\r\nhave large values transferring to and from a simple key (as opposed to a member\r\nof a set or a sorted set). To work exclusively with raw data, I recommend using\r\n`RedisClient<byte[]>` instead which uses an direct buffer read/write\r\nserializer internally.\r\n\r\n**Streaming**\r\n\r\nInstead of a normal string or the specified type, streamed mode commands\r\naccepts `System.IO.Stream` instead so you can send and receive data to and\r\nfrom streams such as `FileStream`, `NetworkStream` or ASP.NET `OutputStream`\r\ndirectly to and from Redis with minimal bufferring:\r\n\r\n    var client = new RedisClient();\r\n\r\n    // load file content straight into redis\r\n    var filename = @\"C:\\temp\\really_really_large_file.txt\";\r\n    using (var fs = File.OpenRead(filename)) {\r\n      client.SetFrom(\"really_large_file\", fs, (int)file.Length);\r\n      fs.Close();\r\n    }\r\n\r\n    // writes out the content of a key to a file\r\n    using (var fs = File.OpenWrite(filename)) {\r\n      var bytesWrote = client.GetTo(\"really_large_file\", fs);\r\n      Console.WriteLine(\"Written {0} bytes of key `{1}`'s content.\",\r\n        bytesWrote, filename);\r\n    }\r\n\r\nSee the `StreamingSample.cs` file in the `src/Sider.Samples` folder for\r\na sample implementation.\r\n\r\n**Raw**\r\n\r\nAdditionally, there are also raw data mode commands which accepts `byte[]`\r\nbuffers directly:\r\n\r\n    // create random buffer\r\n    var temp = new byte[4096];\r\n    (new Random()).NextBytes(temp);\r\n\r\n    // work with\r\n    client.SetRaw(\"random\", temp);\r\n\r\n    var result = client.GetRaw(\"random\");\r\n    for (var i = 0; i < result.Length; i++)\r\n      Trace.Assert(result[i] == temp[i]);\r\n\r\nJust note the `-Raw` suffix.\r\n\r\n# TRANSACTIONS\r\n\r\nTransactions handling are automatic from the user persepective.\r\nJust issue a `MULTI` like you would do via `redis-cli` and the client\r\nwill enter transaction mode automatically. While in transaction mode,\r\nplease note the following points:\r\n\r\nAfter `MULTI` all non-trasaction commands will result in a `+QUEUED`\r\nresponse instead of the command's normal response. So return values\r\nfrom commands after `.Multi()` is meaningless.\r\n\r\n    var client = new RedisClient();\r\n\r\n    // Enter transaction mode\r\n    client.Multi();\r\n\r\n    // x is meaningless since Redis will returns a +QUEUED\r\n    var x = client.Get(\"X\");\r\n\r\n    // (continued...)\r\n\r\nAll command results will be recorded just like when you perform a\r\n`.Pipeline()` call. Recorded results will be read out after you\r\nissue an `EXEC` just like via `redis-cli`\r\n\r\n    // (continued...)\r\n    var result = client.Exec().ToArray();\r\n\r\n    // result contains 1 element since we've issued\r\n    // only 1 command so far in transaction mode\r\n    var actualXvalue = result[0]; // from .Get(\"X\") above\r\n\r\n  That is `.Exec()` will returns an `IEnumerable<object>` with as much\r\n  elements as the number of commands you've issued since `.Multi()`\r\n\r\nLikewise, `DISCARD` discards all the commands recorded so far and simply\r\nexits transaction mode.\r\n\r\n    // set a sample value\r\n    client.Set(\"X\", \"Foobar!\");\r\n\r\n    // perform an aborted transaction\r\n    client.Multi();\r\n    client.Set(\"X\", \"NO\");\r\n    client.Discard();\r\n\r\n    // check result\r\n    var result = client.Get(\"X\");\r\n\r\n    // X == \"Foobar!\"\r\n\r\nPlease see the `MultiExecSample.cs` file in the `src\\Sider.Samples`\r\nfolder for a complete and working example.\r\n \r\n# CONFIGURATION\r\n\r\nYou can fine-tune buffer sizes to your liking and provide custom serializers\r\nby passing a `RedisSettings` instance which are built like this:\r\n\r\n    var settings = RedisSettings.Build()\r\n      .Host(\"192.168.192.111\")  // custom host\r\n      .Port(9736)               // custom port\r\n      .ReconnectOnIdle(false)   // manage timeouts manually\r\n      .ReadBufferSize(256)      // optimize for small reads\r\n      .WriteBufferSize(65536)   // optimize for large writes\r\n\r\n    // pass to pool so all clients use the supplied settings\r\n    var pool = new ThreadwisePool(settings);\r\n    var client = pool.GetClient();\r\n\r\n    // or, pass directly to client\r\n    client = new RedisClient(settings);\r\n\r\n...\r\n\r\n# SUPPORT / CONTRIBUTE\r\n\r\nAny improvements to the code is totally welcome! :)\r\n\r\nPlease post any support request to\r\n[sider-lemonade](http://groups.google.com/group/sider-lemonade) google group.\r\n\r\nOr just shoot me an email at `service @ chakrit . net` (without the spaces) or\r\nif you use twitter, feel free to mention [@chakrit](http://twitter.com/chakrit)\r\nfor help.\r\n\r\n# LICENSE\r\n\r\nCopyright (c) 2011, Chakrit Wichian.\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification,\r\nare permitted provided that the following conditions are met:\r\n\r\nRedistributions of source code must retain the above copyright notice, this list\r\nof conditions and the following disclaimer.\r\n\r\nRedistributions in binary form must reproduce the above copyright notice, this\r\nlist of conditions and the following disclaimer in the documentation and/or\r\nother materials provided with the distribution.\r\n\r\nNeither the name of the Chakrit Wichian nor the names of its contributors may be\r\nused to endorse or promote products derived from this software without specific\r\nprior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}